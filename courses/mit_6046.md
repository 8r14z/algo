## [MIT 6.046J Design and Analysis of Algorithms](https://www.youtube.com/playlist?list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp) <a name="design_and_analysis"></a>

### 1. Interval scheduling
Solved by `greedy algorithm`.

Greedy algorithm is a myopic algorithm that process the input one piece at the time with no parent lookahead. 

We try to maximize/minimize the very first thing we can. Looking at the small part of the problem and decide what to do, then we can solve a smaller problem as we solve a part of it

Time scheduling: [implementation](../source/problems/time_sheduling.py)

### 2. Divide and Conquer
Given a problem of size N, divide it into "a" subproblems of size n/b. Solve each subproblem recursively. Combine solutions of subproblems into overall solution

#### Convex hull
Have set of points, draw the smalles pylogon that includes all points

- Brute-force: for each point, draw to other points and select a line that devide points into 2 planes, and other points stay in one side of the line. So on and so forth

Complexity O(n<sup>3</sup>)

```python 
# pesudo-code
def convex_hull(points):
    res = 
    n = len(points)
    for i in range(n):
        for j in range(n)
            if j == i: continue
            else:
                line = draw_line(i,j)
                for x in range(n):
                    if x != i and x != j:
                        if x in same side as others:
                            res.append(i)
    res
```

- Devide and conquer: devide the set into 2 subsets and sort the points...

then merge 2 subsets by finding lower bounding and upper bounding between 2 subsets.

Divide the set recursively so we have max log(n) level and at each level we do n work to merge 2 subset -> Complexity O(nlog(n))

#### Median Finding
Given set of n numbers, define rank(x) as the number in the set that are <= x

This is find k-largest number in the array problem :) Can be solved in linear time with partition :)

[Implementation](../source/problems/find_k_largest.py)
